import time
import os
import cv2 as cv
from collections import defaultdict
from datetime import datetime
from flask import g, current_app
from flaskr.db import get_tenant_db
from flaskr.entities.Alert import Alert, AlertStatus # Assuming AlertStatus is in Alert.py

class AlertManager:
    def __init__(self, app_instance, tenant_id):
        """
        Initializes the AlertManager.

        Args:
            app_instance: The Flask application instance.
            tenant_id: The ID of the tenant this manager operates within.
        """
        self.app_instance = app_instance
        self.tenant_id = tenant_id
        # Cooldown dictionary: {rule_id: last_alert_timestamp}
        self.alert_cooldowns = defaultdict(lambda: 0)
        # Cooldown period in seconds (e.g., 60 seconds)
        self.cooldown_period = 60

    def process_alert(self, alert, frame=None):
        """
        Processes a generated alert: checks cooldown, saves screenshot, saves to DB.

        Args:
            alert (Alert): The Alert object generated by RuleInference.
            frame (numpy.ndarray, optional): The video frame for the screenshot. Defaults to None.
        
        Returns:
            bool: True if alert was successfully processed and saved, False otherwise.
        """
        current_time = time.time()
        # Assuming rule_id is attached to the alert object by RuleInference
        rule_id = getattr(alert, 'alert_rule_id', None)

        # --- Cooldown Check ---
        # Only apply cooldown if rule_id is available and cooldown is enabled
        if rule_id and self.cooldown_period > 0:
            last_alert_time = self.alert_cooldowns.get(rule_id, 0)
            if current_time - last_alert_time < self.cooldown_period:
                # Optional: Log skipped alert
                print(f"Alert for rule {rule_id} skipped due to cooldown (last alert: {current_time - last_alert_time:.2f}s ago).")
                return False # Skip alert due to cooldown
        # --------------------

        # --- Establish Context and Save ---
        with self.app_instance.app_context():
            g.tenant_id = self.tenant_id # Set tenant context for this operation
            db = get_tenant_db()
            alerts_path = self.app_instance.config.get('ALERTS_SCREENSHOTS_PATH', 'flaskr/static/alerts') # Get path from config or default

            # --- Save Screenshot (if frame provided and path needed) ---
            screenshot_filename = None
            if frame is not None and not getattr(alert, 'screenshot', None): # Only save if not already set
                try:
                    success, jpeg_frame = cv.imencode('.jpg', frame)
                    if success:
                        os.makedirs(alerts_path, exist_ok=True)
                        # Use a more descriptive name including tenant_id to avoid collisions
                        filename = f"alert_{self.tenant_id}_{alert.type.value}_{int(current_time)}.jpg"
                        full_screenshot_path = os.path.join(alerts_path, filename)
                        with open(full_screenshot_path, "wb") as f:
                            f.write(jpeg_frame.tobytes())
                        # Store relative path or just filename if served statically
                        alert.screenshot = filename # Store filename or relative path
                        screenshot_filename = filename # Keep track for logging
                    else:
                        print(f"Failed to encode screenshot for alert type {alert.type.value}.")
                except Exception as e:
                     print(f"Error saving screenshot for alert type {alert.type.value}: {e}")
            # -------------------------------------------------------

            # --- Save Alert to DB ---
            try:
                # Ensure required fields are set (adjust based on Alert entity)
                alert.status = alert.status or AlertStatus.ACTIVE # Ensure status is set
                alert.timestamp = alert.timestamp or datetime.now() # Ensure timestamp

                # Always commit the alert to the database
                db.add(alert)
                db.commit()
                
                print(f"Alert (Rule: {rule_id}, Type: {alert.type.value}, Screenshot: {screenshot_filename}) saved successfully for tenant {self.tenant_id}.")

                # Update cooldown timestamp after successful save
                if rule_id and self.cooldown_period > 0:
                    self.alert_cooldowns[rule_id] = current_time

                # Return success
                return True

            except Exception as e:
                # Handle database errors
                db.rollback()
                print(f"ERROR saving alert (Rule: {rule_id}, Type: {alert.type.value}) to database for tenant {self.tenant_id}: {e}")
                
                # Try a second time with a simplified alert if the first attempt failed
                try:
                    # Create a more basic alert with only essential attributes
                    simplified_alert = Alert(
                        type=alert.type,
                        level=alert.level,
                        timestamp=datetime.now(),
                        status=AlertStatus.ACTIVE,
                        explanation=f"Alert for rule {rule_id}" if rule_id else "System alert",
                    )
                    db.add(simplified_alert)
                    db.commit()
                    print(f"Simplified fallback alert saved successfully for tenant {self.tenant_id}.")
                    return True
                except Exception as e2:
                    db.rollback()
                    print(f"CRITICAL ERROR: Failed to save even simplified alert: {e2}")
                    return False
            # ------------------------